=== backend/backend.py ===
"""
Swing Trade Analyzer Backend - v2.1
Flask API server with yfinance (prices) + Defeat Beta (fundamentals)

Day 6: Fixed numpy type serialization issues
- VIX endpoint: bool() and float() conversions
- Fundamentals endpoint: DataFrame value conversions
"""

from flask import Flask, jsonify
from flask_cors import CORS
import yfinance as yf
from datetime import datetime, timedelta
import traceback

# Try to import defeatbeta - graceful fallback if not installed
try:
    import defeatbeta_api
    from defeatbeta_api.data.ticker import Ticker as DBTicker
    DEFEATBETA_AVAILABLE = True
    print("‚úÖ Defeat Beta loaded successfully")
except ImportError:
    DEFEATBETA_AVAILABLE = False
    print("‚ö†Ô∏è  Defeat Beta not installed - using yfinance fallback for fundamentals")
    print("   Install with: pip install defeatbeta-api")

app = Flask(__name__)
CORS(app)

# ============================================
# HELPER FUNCTIONS
# ============================================

def safe_float(value, default=None):
    """Safely convert numpy/pandas types to Python float"""
    try:
        if value is None:
            return default
        # Handle pandas/numpy types
        if hasattr(value, 'item'):
            return float(value.item())
        return float(value)
    except (TypeError, ValueError):
        return default


def safe_int(value, default=None):
    """Safely convert numpy/pandas types to Python int"""
    try:
        if value is None:
            return default
        if hasattr(value, 'item'):
            return int(value.item())
        return int(value)
    except (TypeError, ValueError):
        return default


def safe_bool(value, default=False):
    """Safely convert numpy bool to Python bool"""
    try:
        if value is None:
            return default
        if hasattr(value, 'item'):
            return bool(value.item())
        return bool(value)
    except (TypeError, ValueError):
        return default


def safe_get(data, key, default=None):
    """Safely get a value from a dictionary"""
    try:
        value = data.get(key, default)
        if value is None:
            return default
        return value
    except:
        return default


def calculate_growth_rate(current, previous):
    """Calculate percentage growth rate"""
    try:
        if previous is None or previous == 0:
            return None
        current = safe_float(current)
        previous = safe_float(previous)
        if current is None or previous is None or previous == 0:
            return None
        return ((current - previous) / abs(previous)) * 100
    except:
        return None


def get_fundamentals_defeatbeta(ticker_symbol):
    """
    Get rich fundamental data from Defeat Beta
    Returns ROE, ROIC, ROA, EPS growth, revenue growth, etc.
    """
    if not DEFEATBETA_AVAILABLE:
        return None
    
    try:
        ticker = DBTicker(ticker_symbol)
        
        # Initialize result
        result = {
            'source': 'defeatbeta',
            'roe': None,
            'roic': None,
            'roa': None,
            'epsGrowth': None,
            'revenueGrowth': None,
            'debtToEquity': None,
            'profitMargin': None,
            'operatingMargin': None,
            'pegRatio': None
        }
        
        # Track data we've collected
        net_income = None
        total_equity = None
        total_assets = None
        total_debt = None
        
        # Try to get annual income statement for growth calculations
        try:
            annual_income = ticker.annual_income_statement()
            if hasattr(annual_income, 'to_df'):
                annual_df = annual_income.to_df()
                
                if annual_df is not None and len(annual_df.columns) >= 2:
                    cols = list(annual_df.columns)
                    current_year = cols[0]  # Most recent
                    prev_year = cols[1]     # Previous year
                    
                    # Calculate EPS Growth (YoY)
                    for idx in annual_df.index:
                        idx_str = str(idx)
                        if 'Diluted EPS' in idx_str or 'Basic EPS' in idx_str:
                            try:
                                current_eps = safe_float(annual_df.loc[idx, current_year])
                                prev_eps = safe_float(annual_df.loc[idx, prev_year])
                                if current_eps is not None and prev_eps is not None and prev_eps != 0:
                                    result['epsGrowth'] = round(((current_eps - prev_eps) / abs(prev_eps)) * 100, 2)
                            except:
                                pass
                            break
                    
                    # Calculate Revenue Growth
                    for idx in annual_df.index:
                        idx_str = str(idx)
                        if 'Total Revenue' in idx_str or 'Operating Revenue' in idx_str:
                            try:
                                current_rev = safe_float(annual_df.loc[idx, current_year])
                                prev_rev = safe_float(annual_df.loc[idx, prev_year])
                                if current_rev is not None and prev_rev is not None and prev_rev != 0:
                                    result['revenueGrowth'] = round(((current_rev - prev_rev) / abs(prev_rev)) * 100, 2)
                            except:
                                pass
                            break
                    
                    # Get Net Income for ROE/ROA calculations
                    for idx in annual_df.index:
                        idx_str = str(idx)
                        if 'Net Income' in idx_str and 'Non' not in idx_str:
                            try:
                                net_income = safe_float(annual_df.loc[idx, current_year])
                            except:
                                pass
                            break
                    
                    # Calculate Profit Margin
                    for idx in annual_df.index:
                        if 'Total Revenue' in str(idx):
                            try:
                                revenue = safe_float(annual_df.loc[idx, current_year])
                                if net_income is not None and revenue is not None and revenue != 0:
                                    result['profitMargin'] = round((net_income / revenue) * 100, 2)
                            except:
                                pass
                            break
                            
        except Exception as e:
            print(f"Error getting annual income: {e}")
        
        # Try to get balance sheet for ROE, ROIC, Debt/Equity
        try:
            annual_balance = ticker.annual_balance_sheet()
            if hasattr(annual_balance, 'to_df'):
                balance_df = annual_balance.to_df()
                
                if balance_df is not None and len(balance_df.columns) >= 1:
                    current_col = list(balance_df.columns)[0]
                    
                    for idx in balance_df.index:
                        idx_str = str(idx)
                        try:
                            if 'Stockholder' in idx_str and 'Equity' in idx_str:
                                total_equity = safe_float(balance_df.loc[idx, current_col])
                            elif 'Total Assets' in idx_str and total_assets is None:
                                total_assets = safe_float(balance_df.loc[idx, current_col])
                            elif 'Total Debt' in idx_str:
                                total_debt = safe_float(balance_df.loc[idx, current_col])
                        except:
                            pass
                    
                    # Calculate Debt to Equity
                    if total_equity and total_equity != 0 and total_debt:
                        result['debtToEquity'] = round(total_debt / total_equity, 2)
                    
                    # Calculate ROE = Net Income / Shareholders Equity
                    if net_income and total_equity and total_equity != 0:
                        result['roe'] = round((net_income / total_equity) * 100, 2)
                    
                    # Calculate ROA = Net Income / Total Assets
                    if net_income and total_assets and total_assets != 0:
                        result['roa'] = round((net_income / total_assets) * 100, 2)
                    
                    # Calculate ROIC (simplified) = Net Income / (Equity + Debt)
                    invested_capital = (total_equity or 0) + (total_debt or 0)
                    if net_income and invested_capital != 0:
                        result['roic'] = round((net_income / invested_capital) * 100, 2)
                        
        except Exception as e:
            print(f"Error getting balance sheet: {e}")
        
        return result
        
    except Exception as e:
        print(f"Error in get_fundamentals_defeatbeta: {e}")
        traceback.print_exc()
        return None


def get_fundamentals_yfinance(ticker_symbol):
    """
    Fallback: Get basic fundamental data from yfinance
    Limited data but always available
    """
    try:
        stock = yf.Ticker(ticker_symbol)
        info = stock.info
        
        # Get financials for growth calculations
        rev_growth = None
        net_income = None
        try:
            financials = stock.quarterly_financials
            if financials is not None and len(financials.columns) >= 2:
                if 'Total Revenue' in financials.index:
                    current_rev = safe_float(financials.loc['Total Revenue'].iloc[0])
                    prev_rev = safe_float(financials.loc['Total Revenue'].iloc[1])
                    if current_rev and prev_rev and prev_rev != 0:
                        rev_growth = round(((current_rev - prev_rev) / abs(prev_rev)) * 100, 2)
                        
                if 'Net Income' in financials.index:
                    net_income = safe_float(financials.loc['Net Income'].iloc[0])
        except:
            pass
        
        # Get balance sheet for ROE calculation
        roe = None
        roa = None
        debt_to_equity = None
        try:
            balance = stock.quarterly_balance_sheet
            if balance is not None and len(balance.columns) >= 1:
                equity = None
                total_assets = None
                total_debt = None
                
                if 'Stockholders Equity' in balance.index:
                    equity = safe_float(balance.loc['Stockholders Equity'].iloc[0])
                elif 'Total Stockholder Equity' in balance.index:
                    equity = safe_float(balance.loc['Total Stockholder Equity'].iloc[0])
                    
                if 'Total Assets' in balance.index:
                    total_assets = safe_float(balance.loc['Total Assets'].iloc[0])
                    
                if 'Total Debt' in balance.index:
                    total_debt = safe_float(balance.loc['Total Debt'].iloc[0])
                
                # Calculate metrics
                if net_income and equity and equity != 0:
                    roe = round((net_income / equity) * 100, 2)
                if net_income and total_assets and total_assets != 0:
                    roa = round((net_income / total_assets) * 100, 2)
                if total_debt and equity and equity != 0:
                    debt_to_equity = round(total_debt / equity, 2)
        except:
            pass
        
        return {
            'source': 'yfinance',
            'pe': safe_float(safe_get(info, 'trailingPE')),
            'forwardPe': safe_float(safe_get(info, 'forwardPE')),
            'pegRatio': safe_float(safe_get(info, 'pegRatio')),
            'marketCap': safe_int(safe_get(info, 'marketCap')),
            'roe': roe or safe_float(safe_get(info, 'returnOnEquity')),
            'roa': roa or safe_float(safe_get(info, 'returnOnAssets')),
            'roic': None,
            'epsGrowth': safe_float(safe_get(info, 'earningsGrowth')),
            'revenueGrowth': rev_growth or safe_float(safe_get(info, 'revenueGrowth')),
            'debtToEquity': debt_to_equity or safe_float(safe_get(info, 'debtToEquity')),
            'profitMargin': safe_float(safe_get(info, 'profitMargins')),
            'operatingMargin': safe_float(safe_get(info, 'operatingMargins')),
            'beta': safe_float(safe_get(info, 'beta')),
            'dividendYield': safe_float(safe_get(info, 'dividendYield')),
        }
        
    except Exception as e:
        print(f"Error in get_fundamentals_yfinance: {e}")
        return None


# ============================================
# API ROUTES
# ============================================

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'version': '2.1',
        'defeatbeta_available': DEFEATBETA_AVAILABLE
    })


@app.route('/api/stock/<ticker>', methods=['GET'])
def get_stock_data(ticker):
    """
    Get stock data for analysis
    Uses yfinance for price data (real-time)
    """
    try:
        ticker = ticker.upper()
        stock = yf.Ticker(ticker)
        
        # Get historical data (260 trading days for 52-week calculations)
        hist = stock.history(period='2y')
        
        if hist.empty:
            return jsonify({'error': f'No data found for {ticker}'}), 404
        
        # FIXED: Get last 260 days (covers full 52 weeks of trading)
        hist_data = hist.tail(260)
        
        # Get stock info
        info = stock.info
        
        # Prepare price history
        price_history = []
        for date, row in hist_data.iterrows():
            price_history.append({
                'date': date.strftime('%Y-%m-%d'),
                'open': round(float(row['Open']), 2),
                'high': round(float(row['High']), 2),
                'low': round(float(row['Low']), 2),
                'close': round(float(row['Close']), 2),
                'volume': int(row['Volume'])
            })
        
        # Get 52-week ago price (approximately 252 trading days)
        price_52w_ago = None
        if len(hist_data) >= 252:
            price_52w_ago = round(float(hist_data.iloc[-252]['Close']), 2)
        elif len(hist_data) > 200:
            price_52w_ago = round(float(hist_data.iloc[0]['Close']), 2)
        
        # Get 13-week ago price (approximately 63 trading days)
        price_13w_ago = None
        if len(hist_data) >= 63:
            price_13w_ago = round(float(hist_data.iloc[-63]['Close']), 2)
        
        # Current price
        current_price = round(float(hist_data.iloc[-1]['Close']), 2)
        
        # Basic fundamentals from yfinance (for backward compatibility)
        fundamentals = {
            'pe': safe_float(safe_get(info, 'trailingPE')),
            'forwardPe': safe_float(safe_get(info, 'forwardPE')),
            'marketCap': safe_int(safe_get(info, 'marketCap')),
            'beta': safe_float(safe_get(info, 'beta')),
            'dividendYield': safe_float(safe_get(info, 'dividendYield')),
            'epsGrowth': 0,
            'revenueGrowth': 0,
            'roe': 0,
            'roic': 0,
            'debtToEquity': 0
        }
        
        response = {
            'ticker': ticker,
            'name': safe_get(info, 'shortName', ticker),
            'sector': safe_get(info, 'sector', 'Unknown'),
            'industry': safe_get(info, 'industry', 'Unknown'),
            'currentPrice': current_price,
            'price52wAgo': price_52w_ago,
            'price13wAgo': price_13w_ago,
            'fiftyTwoWeekHigh': safe_float(safe_get(info, 'fiftyTwoWeekHigh')),
            'fiftyTwoWeekLow': safe_float(safe_get(info, 'fiftyTwoWeekLow')),
            'avgVolume': safe_int(safe_get(info, 'averageVolume')),
            'avgVolume10d': safe_int(safe_get(info, 'averageVolume10days')),
            'priceHistory': price_history,
            'fundamentals': fundamentals,
            'dataPoints': len(price_history),
            'oldestDate': price_history[0]['date'] if price_history else None,
            'newestDate': price_history[-1]['date'] if price_history else None
        }
        
        return jsonify(response)
        
    except Exception as e:
        print(f"Error fetching {ticker}: {e}")
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500


@app.route('/api/fundamentals/<ticker>', methods=['GET'])
def get_fundamentals(ticker):
    """
    Get rich fundamental data for scoring
    Tries Defeat Beta first, falls back to yfinance
    """
    try:
        ticker = ticker.upper()
        
        # Try Defeat Beta first (richer data)
        fundamentals = None
        if DEFEATBETA_AVAILABLE:
            fundamentals = get_fundamentals_defeatbeta(ticker)
        
        # Fallback to yfinance
        if fundamentals is None:
            fundamentals = get_fundamentals_yfinance(ticker)
        
        if fundamentals is None:
            return jsonify({'error': f'Could not get fundamentals for {ticker}'}), 404
        
        # Add ticker to response
        fundamentals['ticker'] = ticker
        fundamentals['timestamp'] = datetime.now().isoformat()
        
        return jsonify(fundamentals)
        
    except Exception as e:
        print(f"Error fetching fundamentals for {ticker}: {e}")
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500


@app.route('/api/market/spy', methods=['GET'])
def get_spy_data():
    """
    Get SPY (S&P 500 ETF) data for relative strength calculations
    """
    try:
        spy = yf.Ticker('SPY')
        hist = spy.history(period='2y')
        
        if hist.empty:
            return jsonify({'error': 'No SPY data found'}), 404
        
        # Get last 260 days
        hist_data = hist.tail(260)
        
        # Current price - ensure Python float
        current_price = round(float(hist_data.iloc[-1]['Close']), 2)
        
        # 52-week ago price
        price_52w_ago = None
        if len(hist_data) >= 252:
            price_52w_ago = round(float(hist_data.iloc[-252]['Close']), 2)
        elif len(hist_data) > 200:
            price_52w_ago = round(float(hist_data.iloc[0]['Close']), 2)
        
        # 13-week ago price
        price_13w_ago = None
        if len(hist_data) >= 63:
            price_13w_ago = round(float(hist_data.iloc[-63]['Close']), 2)
        
        # Prepare price history
        price_history = []
        for date, row in hist_data.iterrows():
            price_history.append({
                'date': date.strftime('%Y-%m-%d'),
                'close': round(float(row['Close']), 2),
                'volume': int(row['Volume'])
            })
        
        # Calculate 200 SMA for market regime
        sma_200 = round(float(hist_data['Close'].tail(200).mean()), 2)
        
        response = {
            'ticker': 'SPY',
            'currentPrice': current_price,
            'price52wAgo': price_52w_ago,
            'price13wAgo': price_13w_ago,
            'sma200': sma_200,
            'aboveSma200': bool(current_price > sma_200),  # FIX: Convert to Python bool
            'priceHistory': price_history,
            'dataPoints': len(price_history)
        }
        
        return jsonify(response)
        
    except Exception as e:
        print(f"Error fetching SPY: {e}")
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500


@app.route('/api/market/vix', methods=['GET'])
def get_vix_data():
    """
    Get VIX (Volatility Index) data for risk assessment
    """
    try:
        vix = yf.Ticker('^VIX')
        hist = vix.history(period='1mo')
        
        if hist.empty:
            return jsonify({'error': 'No VIX data found'}), 404
        
        # FIX: Convert numpy float to Python float
        current_vix = float(hist.iloc[-1]['Close'])
        current_vix = round(current_vix, 2)
        
        # VIX levels interpretation
        if current_vix < 15:
            regime = 'low_volatility'
        elif current_vix < 20:
            regime = 'normal'
        elif current_vix < 25:
            regime = 'elevated'
        elif current_vix < 30:
            regime = 'high'
        else:
            regime = 'extreme'
        
        return jsonify({
            'ticker': 'VIX',
            'current': current_vix,
            'regime': regime,
            # FIX: Convert numpy.bool_ to Python bool
            'isRisky': bool(current_vix > 30)
        })
        
    except Exception as e:
        print(f"Error fetching VIX: {e}")
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500


# ============================================
# MAIN
# ============================================

if __name__ == '__main__':
    print("\n" + "="*50)
    print("üöÄ Swing Trade Analyzer Backend v2.1")
    print("="*50)
    print(f"Defeat Beta: {'‚úÖ Available' if DEFEATBETA_AVAILABLE else '‚ùå Not installed'}")
    print("Starting server on port 5001...")
    print("="*50 + "\n")
    
    app.run(debug=True, port=5001)

=== frontend/src/utils/rsCalculator.js ===
/**
 * Relative Strength (RS) Calculator
 * 
 * RS is THE #1 predictor for swing trading success.
 * Based on Mark Minervini's SEPA and William O'Neil's methodology.
 * 
 * Formula: RS = (Stock % Change) / (SPY % Change)
 * - RS > 1.0 = Outperforming the market
 * - RS < 1.0 = Underperforming the market
 */

/**
 * Calculate Relative Strength vs S&P 500
 * 
 * @param {Object} stockData - Stock data from backend
 * @param {Object} spyData - SPY data from backend
 * @returns {Object} RS metrics
 */
export function calculateRelativeStrength(stockData, spyData) {
  try {
    // Extract prices
    const stockCurrent = stockData.currentPrice;
    const stock52wAgo = stockData.price52WeeksAgo;
    const stock13wAgo = stockData.price13WeeksAgo;
    
    const spyCurrent = spyData.currentPrice;
    const spy52wAgo = spyData.price52WeeksAgo;
    const spy13wAgo = spyData.price13WeeksAgo;
    
    // Validate we have all required data
    if (!stockCurrent || !stock52wAgo || !spyCurrent || !spy52wAgo) {
      console.error('Missing price data for RS calculation');
      return {
        rs52Week: null,
        rs13Week: null,
        rsRating: null,
        rsTrend: 'unknown',
        error: 'Insufficient data for RS calculation'
      };
    }
    
    // Calculate 52-week RS
    // RS = (Stock Today / Stock 52w Ago) / (SPY Today / SPY 52w Ago)
    const stockReturn52w = stockCurrent / stock52wAgo;
    const spyReturn52w = spyCurrent / spy52wAgo;
    const rs52Week = stockReturn52w / spyReturn52w;
    
    // Calculate 13-week RS (short-term momentum)
    let rs13Week = null;
    if (stock13wAgo && spy13wAgo) {
      const stockReturn13w = stockCurrent / stock13wAgo;
      const spyReturn13w = spyCurrent / spy13wAgo;
      rs13Week = stockReturn13w / spyReturn13w;
    }
    
    // Determine RS trend
    // Improving: 13-week RS > 52-week RS (recent outperformance accelerating)
    let rsTrend = 'stable';
    if (rs13Week !== null) {
      if (rs13Week > rs52Week * 1.05) {
        rsTrend = 'improving';
      } else if (rs13Week < rs52Week * 0.95) {
        rsTrend = 'declining';
      }
    }
    
    // Calculate RS Rating (0-100 scale)
    // This is a simplified version - ideally would be percentile vs all stocks
    // For now: RS of 1.5 = 90, RS of 1.0 = 50, RS of 0.5 = 10
    const rsRating = Math.min(99, Math.max(1, Math.round((rs52Week - 0.5) * 80 + 10)));
    
    // Calculate percentage returns for display
    const stockPctChange52w = ((stockCurrent / stock52wAgo) - 1) * 100;
    const spyPctChange52w = ((spyCurrent / spy52wAgo) - 1) * 100;
    
    let stockPctChange13w = null;
    let spyPctChange13w = null;
    if (stock13wAgo && spy13wAgo) {
      stockPctChange13w = ((stockCurrent / stock13wAgo) - 1) * 100;
      spyPctChange13w = ((spyCurrent / spy13wAgo) - 1) * 100;
    }
    
    return {
      // Core RS values
      rs52Week: parseFloat(rs52Week.toFixed(3)),
      rs13Week: rs13Week ? parseFloat(rs13Week.toFixed(3)) : null,
      rsRating: rsRating,
      rsTrend: rsTrend,
      
      // Supporting data
      stockReturn52w: parseFloat(stockPctChange52w.toFixed(2)),
      spyReturn52w: parseFloat(spyPctChange52w.toFixed(2)),
      stockReturn13w: stockPctChange13w ? parseFloat(stockPctChange13w.toFixed(2)) : null,
      spyReturn13w: spyPctChange13w ? parseFloat(spyPctChange13w.toFixed(2)) : null,
      
      // Interpretation
      interpretation: interpretRS(rs52Week, rs13Week, rsTrend),
      
      // Scoring for the 75-point system (RS is worth 10 points)
      score: calculateRSScore(rs52Week),
      
      // Quality gate check
      passesQualityGate: rs52Week >= 0.8,
      
      error: null
    };
  } catch (error) {
    console.error('Error calculating RS:', error);
    return {
      rs52Week: null,
      rs13Week: null,
      rsRating: null,
      rsTrend: 'unknown',
      error: error.message
    };
  }
}

/**
 * Calculate RS score for the 75-point scoring system
 * RS is worth 10 points max
 * 
 * @param {number} rs52Week - 52-week RS value
 * @returns {number} Score from 0-10
 */
function calculateRSScore(rs52Week) {
  if (rs52Week === null) return 0;
  
  // Scoring thresholds based on Minervini's guidelines
  if (rs52Week >= 1.3) return 10;      // Top performers (RS 130%+)
  if (rs52Week >= 1.2) return 9;       // Strong outperformance
  if (rs52Week >= 1.1) return 7;       // Good outperformance
  if (rs52Week >= 1.0) return 5;       // Market performer
  if (rs52Week >= 0.9) return 3;       // Slight underperformance
  if (rs52Week >= 0.8) return 1;       // Underperforming (quality gate threshold)
  return 0;                             // Significant underperformer
}

/**
 * Provide human-readable interpretation of RS
 * 
 * @param {number} rs52Week - 52-week RS
 * @param {number} rs13Week - 13-week RS
 * @param {string} rsTrend - Trend direction
 * @returns {string} Interpretation text
 */
function interpretRS(rs52Week, rs13Week, rsTrend) {
  if (rs52Week === null) return 'Unable to calculate RS';
  
  let interpretation = '';
  
  // Base interpretation
  if (rs52Week >= 1.3) {
    interpretation = 'Exceptional strength - Top tier performer';
  } else if (rs52Week >= 1.2) {
    interpretation = 'Strong outperformance vs market';
  } else if (rs52Week >= 1.1) {
    interpretation = 'Good relative strength';
  } else if (rs52Week >= 1.0) {
    interpretation = 'Performing in-line with market';
  } else if (rs52Week >= 0.9) {
    interpretation = 'Slight underperformance';
  } else if (rs52Week >= 0.8) {
    interpretation = 'Underperforming - Caution advised';
  } else {
    interpretation = 'Significant laggard - Avoid for swing trades';
  }
  
  // Add trend context
  if (rsTrend === 'improving') {
    interpretation += ' (momentum accelerating)';
  } else if (rsTrend === 'declining') {
    interpretation += ' (momentum fading)';
  }
  
  return interpretation;
}

/**
 * Check if RS passes quality gate
 * Stocks with RS < 0.8 should be auto-avoided
 * 
 * @param {number} rs52Week - 52-week RS value
 * @returns {Object} Quality gate result
 */
export function checkRSQualityGate(rs52Week) {
  if (rs52Week === null) {
    return {
      passes: false,
      reason: 'Unable to calculate RS',
      severity: 'critical'
    };
  }
  
  if (rs52Week < 0.8) {
    return {
      passes: false,
      reason: `RS of ${rs52Week.toFixed(2)} is below 0.8 threshold - significant market underperformer`,
      severity: 'critical'
    };
  }
  
  if (rs52Week < 1.0) {
    return {
      passes: true,
      reason: `RS of ${rs52Week.toFixed(2)} is below market - proceed with caution`,
      severity: 'warning'
    };
  }
  
  return {
    passes: true,
    reason: `RS of ${rs52Week.toFixed(2)} shows market outperformance`,
    severity: 'none'
  };
}

/**
 * Format RS for display
 * 
 * @param {number} rs - RS value
 * @returns {string} Formatted RS string
 */
export function formatRS(rs) {
  if (rs === null || rs === undefined) return 'N/A';
  return rs.toFixed(2);
}

/**
 * Get RS color for UI display
 * 
 * @param {number} rs - RS value
 * @returns {string} Tailwind color class
 */
export function getRSColor(rs) {
  if (rs === null || rs === undefined) return 'text-gray-500';
  if (rs >= 1.2) return 'text-green-600';
  if (rs >= 1.0) return 'text-green-500';
  if (rs >= 0.9) return 'text-yellow-500';
  if (rs >= 0.8) return 'text-orange-500';
  return 'text-red-500';
}

/**
 * Get RS trend icon
 * 
 * @param {string} trend - RS trend ('improving', 'declining', 'stable')
 * @returns {string} Emoji or icon character
 */
export function getRSTrendIcon(trend) {
  switch (trend) {
    case 'improving': return '‚ÜóÔ∏è';
    case 'declining': return '‚ÜòÔ∏è';
    case 'stable': return '‚Üí';
    default: return '?';
  }
}


=== frontend/src/services/api.js ===
/**
 * API Service for Swing Trade Analyzer
 * Connects to Flask backend on port 5001
 * 
 * v2.0: Added fundamentals endpoint for rich fundamental data
 */

const API_BASE_URL = 'http://localhost:5001/api';

/**
 * Fetch stock data for a given ticker
 * Returns price history, basic info, and volume data
 */
export async function fetchStockData(ticker) {
  try {
    const response = await fetch(`${API_BASE_URL}/stock/${ticker.toUpperCase()}`);
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `Failed to fetch ${ticker}`);
    }
    
    const data = await response.json();
    
    // Transform data for frontend consumption
    return {
      ticker: data.ticker,
      name: data.name,
      sector: data.sector,
      industry: data.industry,
      currentPrice: data.currentPrice,
      price52wAgo: data.price52wAgo,
      price13wAgo: data.price13wAgo,
      fiftyTwoWeekHigh: data.fiftyTwoWeekHigh,
      fiftyTwoWeekLow: data.fiftyTwoWeekLow,
      avgVolume: data.avgVolume,
      avgVolume10d: data.avgVolume10d,
      priceHistory: data.priceHistory,
      fundamentals: data.fundamentals,
      dataPoints: data.dataPoints,
      oldestDate: data.oldestDate,
      newestDate: data.newestDate
    };
    
  } catch (error) {
    console.error('Error fetching stock data:', error);
    throw error;
  }
}

/**
 * Fetch rich fundamental data for scoring
 * Uses Defeat Beta if available, falls back to yfinance
 * 
 * Returns:
 * - ROE, ROIC, ROA
 * - EPS Growth, Revenue Growth
 * - Debt/Equity, Profit Margins
 */
export async function fetchFundamentals(ticker) {
  try {
    const response = await fetch(`${API_BASE_URL}/fundamentals/${ticker.toUpperCase()}`);
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || `Failed to fetch fundamentals for ${ticker}`);
    }
    
    const data = await response.json();
    
    // Return normalized fundamental data
    return {
      source: data.source,
      ticker: data.ticker,
      roe: data.roe,
      roic: data.roic,
      roa: data.roa,
      epsGrowth: data.epsGrowth,
      revenueGrowth: data.revenueGrowth,
      debtToEquity: data.debtToEquity,
      profitMargin: data.profitMargin,
      operatingMargin: data.operatingMargin,
      pegRatio: data.pegRatio,
      pe: data.pe,
      forwardPe: data.forwardPe,
      marketCap: data.marketCap,
      beta: data.beta,
      dividendYield: data.dividendYield,
      timestamp: data.timestamp
    };
    
  } catch (error) {
    console.error('Error fetching fundamentals:', error);
    // Return null to indicate failure - caller can handle gracefully
    return null;
  }
}

/**
 * Fetch SPY data for relative strength calculations
 */
export async function fetchSPYData() {
  try {
    const response = await fetch(`${API_BASE_URL}/market/spy`);
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to fetch SPY data');
    }
    
    const data = await response.json();
    
    return {
      ticker: data.ticker,
      currentPrice: data.currentPrice,
      price52wAgo: data.price52wAgo,
      price13wAgo: data.price13wAgo,
      sma200: data.sma200,
      aboveSma200: data.aboveSma200,
      priceHistory: data.priceHistory,
      dataPoints: data.dataPoints
    };
    
  } catch (error) {
    console.error('Error fetching SPY data:', error);
    throw error;
  }
}

/**
 * Fetch VIX data for risk assessment
 */
export async function fetchVIXData() {
  try {
    const response = await fetch(`${API_BASE_URL}/market/vix`);
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to fetch VIX data');
    }
    
    const data = await response.json();
    
    return {
      ticker: data.ticker,
      current: data.current,
      regime: data.regime,
      isRisky: data.isRisky
    };
    
  } catch (error) {
    console.error('Error fetching VIX data:', error);
    // Return safe defaults if VIX fetch fails
    return {
      ticker: 'VIX',
      current: 20,
      regime: 'normal',
      isRisky: false
    };
  }
}

/**
 * Check backend health
 */
export async function checkBackendHealth() {
  try {
    const response = await fetch(`${API_BASE_URL}/health`);
    
    if (!response.ok) {
      return { healthy: false, error: 'Backend not responding' };
    }
    
    const data = await response.json();
    
    return {
      healthy: data.status === 'healthy',
      version: data.version,
      defeatbetaAvailable: data.defeatbeta_available,
      timestamp: data.timestamp
    };
    
  } catch (error) {
    return { healthy: false, error: error.message };
  }
}

/**
 * Fetch all data needed for analysis
 * Combines stock, fundamentals, SPY, and VIX in parallel
 */
export async function fetchAnalysisData(ticker) {
  try {
    // Fetch all data in parallel for speed
    const [stockData, fundamentals, spyData, vixData] = await Promise.all([
      fetchStockData(ticker),
      fetchFundamentals(ticker),
      fetchSPYData(),
      fetchVIXData()
    ]);
    
    // Merge fundamentals into stock data if available
    if (fundamentals) {
      stockData.fundamentals = {
        ...stockData.fundamentals,
        ...fundamentals,
        // Keep track of data source
        enriched: true,
        enrichedSource: fundamentals.source
      };
    }
    
    return {
      stock: stockData,
      spy: spyData,
      vix: vixData,
      fundamentals: fundamentals
    };
    
  } catch (error) {
    console.error('Error fetching analysis data:', error);
    throw error;
  }
}


=== frontend/src/utils/scoringEngine.js ===
/**
 * Scoring Engine for Swing Trade Analyzer
 * 75-point scoring system based on Minervini SEPA + CAN SLIM
 * 
 * v2.0: Enhanced fundamental scoring with Defeat Beta data
 * 
 * Scoring Breakdown:
 * - Technical: 40 points
 * - Fundamental: 20 points (ENHANCED)
 * - Sentiment: 10 points (placeholder)
 * - Risk/Macro: 5 points
 */

import { calculateSMA, calculateEMA, calculateATR } from './technicalIndicators';
import { calculateRelativeStrength } from './rsCalculator';

/**
 * Calculate all technical indicators from price data
 */
function getIndicators(prices, volumes) {
  if (!prices || prices.length < 200) {
    return null;
  }
  
  return {
    sma50: calculateSMA(prices, 50),
    sma200: calculateSMA(prices, 200),
    ema8: calculateEMA(prices, 8),
    ema21: calculateEMA(prices, 21),
    atr: calculateATR(prices, 14),
    avgVolume50: volumes.slice(-50).reduce((a, b) => a + b, 0) / 50
  };
}

/**
 * Calculate Technical Analysis Score (40 points)
 */
function calculateTechnicalScore(stockData, spyData) {
  const prices = stockData.priceHistory.map(d => d.close);
  const volumes = stockData.priceHistory.map(d => d.volume);
  
  if (prices.length < 50) {
    return { score: 0, maxScore: 40, details: {}, error: 'Insufficient price data' };
  }
  
  const indicators = getIndicators(prices, volumes);
  const currentPrice = prices[prices.length - 1];
  
  let scores = {
    trendStructure: 0,
    shortTermTrend: 0,
    volume: 0,
    rs: 0
  };
  
  // 1. Trend Structure (15 points): Price > 50 SMA > 200 SMA
  if (indicators.sma50 && indicators.sma200) {
    if (currentPrice > indicators.sma50 && indicators.sma50 > indicators.sma200) {
      scores.trendStructure = 15; // Perfect Stage 2 uptrend
    } else if (currentPrice > indicators.sma200) {
      scores.trendStructure = 5; // Above 200 SMA but not ideal structure
    }
  }
  
  // 2. Short-term Trend (10 points): Price > 8 EMA > 21 EMA
  if (indicators.ema8 && indicators.ema21) {
    if (currentPrice > indicators.ema8 && indicators.ema8 > indicators.ema21) {
      scores.shortTermTrend = 10; // Strong short-term momentum
    } else if (currentPrice > indicators.ema21) {
      scores.shortTermTrend = 3; // Above 21 EMA
    }
  }
  
  // 3. Volume (5 points): Recent volume vs 50-day average
  if (indicators.avgVolume50) {
    const recentVolume = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
    const volumeRatio = recentVolume / indicators.avgVolume50;
    
    if (volumeRatio >= 1.5) {
      scores.volume = 5; // High volume interest
    } else if (volumeRatio >= 1.0) {
      scores.volume = 2; // Normal volume
    }
  }
  
  // 4. Relative Strength (10 points)
  const rsData = calculateRelativeStrength(stockData, spyData);
  if (rsData && rsData.rs52Week) {
    if (rsData.rs52Week >= 1.5) {
      scores.rs = 10; // Strong outperformance
    } else if (rsData.rs52Week >= 1.2) {
      scores.rs = 7; // Good outperformance
    } else if (rsData.rs52Week >= 1.0) {
      scores.rs = 4; // Slight outperformance
    } else if (rsData.rs52Week >= 0.8) {
      scores.rs = 1; // Slight underperformance
    }
  }
  
  const totalScore = scores.trendStructure + scores.shortTermTrend + scores.volume + scores.rs;
  
  return {
    score: totalScore,
    maxScore: 40,
    details: {
      trendStructure: { score: scores.trendStructure, max: 15 },
      shortTermTrend: { score: scores.shortTermTrend, max: 10 },
      volume: { score: scores.volume, max: 5 },
      relativeStrength: { score: scores.rs, max: 10 }
    },
    indicators: indicators,
    rsData: rsData
  };
}

/**
 * Calculate Fundamental Score (20 points)
 * ENHANCED with Defeat Beta data (ROE, ROIC, EPS Growth, etc.)
 */
function calculateFundamentalScore(fundamentals) {
  let scores = {
    epsGrowth: 0,
    revenueGrowth: 0,
    roe: 0,
    debtToEquity: 0,
    forwardPe: 0
  };
  
  let dataSource = fundamentals?.enrichedSource || fundamentals?.source || 'unknown';
  let dataQuality = 'limited';
  
  // Check if we have enriched data from Defeat Beta
  if (fundamentals?.enriched || fundamentals?.source === 'defeatbeta') {
    dataQuality = 'rich';
  }
  
  // 1. EPS Growth (6 points)
  // Target: >25% YoY = 6pts, 15-25% = 4pts, 10-15% = 2pts
  const epsGrowth = fundamentals?.epsGrowth;
  if (epsGrowth !== null && epsGrowth !== undefined && epsGrowth !== 0) {
    if (epsGrowth >= 25) {
      scores.epsGrowth = 6;
    } else if (epsGrowth >= 15) {
      scores.epsGrowth = 4;
    } else if (epsGrowth >= 10) {
      scores.epsGrowth = 2;
    } else if (epsGrowth > 0) {
      scores.epsGrowth = 1;
    }
  }
  
  // 2. Revenue Growth (5 points)
  // Target: >20% = 5pts, 10-20% = 3pts, 5-10% = 1pt
  const revenueGrowth = fundamentals?.revenueGrowth;
  if (revenueGrowth !== null && revenueGrowth !== undefined && revenueGrowth !== 0) {
    if (revenueGrowth >= 20) {
      scores.revenueGrowth = 5;
    } else if (revenueGrowth >= 10) {
      scores.revenueGrowth = 3;
    } else if (revenueGrowth >= 5) {
      scores.revenueGrowth = 1;
    }
  }
  
  // 3. ROE (4 points)
  // Target: >15% = 4pts, 10-15% = 2pts
  const roe = fundamentals?.roe;
  if (roe !== null && roe !== undefined && roe !== 0) {
    if (roe >= 15) {
      scores.roe = 4;
    } else if (roe >= 10) {
      scores.roe = 2;
    } else if (roe > 0) {
      scores.roe = 1;
    }
  }
  
  // 4. Debt/Equity (3 points)
  // Target: <1.0 = 3pts, 1.0-1.5 = 1pt
  const debtToEquity = fundamentals?.debtToEquity;
  if (debtToEquity !== null && debtToEquity !== undefined) {
    if (debtToEquity < 0.5) {
      scores.debtToEquity = 3; // Very low debt
    } else if (debtToEquity < 1.0) {
      scores.debtToEquity = 2;
    } else if (debtToEquity < 1.5) {
      scores.debtToEquity = 1;
    }
  }
  
  // 5. Forward P/E (2 points)
  // Target: <20 = 2pts, 20-25 = 1pt (reasonable valuation)
  const forwardPe = fundamentals?.forwardPe;
  if (forwardPe !== null && forwardPe !== undefined && forwardPe > 0) {
    if (forwardPe < 20) {
      scores.forwardPe = 2;
    } else if (forwardPe < 25) {
      scores.forwardPe = 1;
    }
  }
  
  const totalScore = scores.epsGrowth + scores.revenueGrowth + scores.roe + 
                     scores.debtToEquity + scores.forwardPe;
  
  return {
    score: totalScore,
    maxScore: 20,
    details: {
      epsGrowth: { score: scores.epsGrowth, max: 6, value: epsGrowth },
      revenueGrowth: { score: scores.revenueGrowth, max: 5, value: revenueGrowth },
      roe: { score: scores.roe, max: 4, value: roe },
      debtToEquity: { score: scores.debtToEquity, max: 3, value: debtToEquity },
      forwardPe: { score: scores.forwardPe, max: 2, value: forwardPe }
    },
    dataSource: dataSource,
    dataQuality: dataQuality
  };
}

/**
 * Calculate Sentiment Score (10 points)
 * Placeholder - real sentiment analysis in v2.0
 */
function calculateSentimentScore() {
  // TODO: Implement real sentiment analysis
  // For now, return neutral score
  return {
    score: 5,
    maxScore: 10,
    details: {
      newsScore: { score: 5, max: 10 }
    },
    note: 'Placeholder - real sentiment coming in v2.0'
  };
}

/**
 * Calculate Risk/Macro Score (5 points)
 */
function calculateRiskScore(spyData, vixData) {
  let scores = {
    vix: 0,
    spyRegime: 0,
    breadth: 0
  };
  
  // 1. VIX Level (2 points)
  const vix = vixData?.current;
  if (vix !== null && vix !== undefined) {
    if (vix < 15) {
      scores.vix = 2; // Low volatility - favorable
    } else if (vix < 20) {
      scores.vix = 1; // Normal volatility
    }
    // VIX > 20 = 0 points (elevated risk)
  }
  
  // 2. S&P 500 Regime (2 points)
  if (spyData?.aboveSma200) {
    scores.spyRegime = 2; // Bullish market regime
  }
  
  // 3. Market Breadth (1 point) - placeholder
  // Would need % of stocks above 50 SMA
  scores.breadth = 1; // Default to neutral
  
  const totalScore = scores.vix + scores.spyRegime + scores.breadth;
  
  return {
    score: totalScore,
    maxScore: 5,
    details: {
      vix: { score: scores.vix, max: 2, value: vix },
      spyRegime: { score: scores.spyRegime, max: 2, aboveSma200: spyData?.aboveSma200 },
      breadth: { score: scores.breadth, max: 1 }
    }
  };
}

/**
 * Check Quality Gates (Auto-AVOID triggers)
 */
function checkQualityGates(stockData, spyData, technicalResult) {
  const gates = [];
  const rsData = technicalResult?.rsData;
  const indicators = technicalResult?.indicators;
  const prices = stockData.priceHistory.map(d => d.close);
  const currentPrice = prices[prices.length - 1];
  
  // 1. RS below 0.8 (significant underperformance)
  if (rsData?.rs52Week && rsData.rs52Week < 0.8) {
    gates.push({
      name: 'RS Below Threshold',
      value: rsData.rs52Week.toFixed(2),
      threshold: '< 0.8',
      critical: true
    });
  }
  
  // 2. Stock below 200 SMA (downtrend)
  if (indicators?.sma200 && currentPrice < indicators.sma200) {
    gates.push({
      name: 'Below 200 SMA',
      value: `$${currentPrice.toFixed(2)}`,
      threshold: `> $${indicators.sma200.toFixed(2)}`,
      critical: true
    });
  }
  
  // 3. Average daily volume < $10M (illiquid)
  const avgVolume = stockData.avgVolume || 0;
  const avgDollarVolume = avgVolume * currentPrice;
  if (avgDollarVolume < 10000000) {
    gates.push({
      name: 'Low Liquidity',
      value: `$${(avgDollarVolume / 1000000).toFixed(1)}M`,
      threshold: '> $10M',
      critical: true
    });
  }
  
  // Count critical failures
  const criticalFails = gates.filter(g => g.critical).length;
  
  return {
    passed: criticalFails === 0,
    gates: gates,
    criticalFails: criticalFails
  };
}

/**
 * Determine Verdict based on score and quality gates
 */
function determineVerdict(totalScore, qualityGates, rsData) {
  // Auto-AVOID conditions
  if (qualityGates.criticalFails >= 2) {
    return {
      verdict: 'AVOID',
      reason: `${qualityGates.criticalFails} critical failures`,
      color: 'red'
    };
  }
  
  if (rsData?.rs52Week && rsData.rs52Week < 0.8) {
    return {
      verdict: 'AVOID',
      reason: 'RS significantly below market',
      color: 'red'
    };
  }
  
  // Score-based verdict
  if (totalScore >= 60 && qualityGates.criticalFails === 0) {
    // Additional check: RS must be >= 1.0 for BUY
    if (rsData?.rs52Week && rsData.rs52Week >= 1.0) {
      return {
        verdict: 'BUY',
        reason: `Strong score (${totalScore}/75) with good RS`,
        color: 'green'
      };
    } else {
      return {
        verdict: 'HOLD',
        reason: 'Good score but RS below 1.0',
        color: 'yellow'
      };
    }
  }
  
  if (totalScore >= 40) {
    return {
      verdict: 'HOLD',
      reason: `Moderate score (${totalScore}/75)`,
      color: 'yellow'
    };
  }
  
  return {
    verdict: 'AVOID',
    reason: `Low score (${totalScore}/75)`,
    color: 'red'
  };
}

/**
 * Main scoring function
 * Calculates complete analysis for a stock
 */
export function calculateScore(stockData, spyData, vixData) {
  // Calculate individual scores
  const technicalAnalysis = calculateTechnicalScore(stockData, spyData);
  const fundamentalAnalysis = calculateFundamentalScore(stockData.fundamentals);
  const sentimentAnalysis = calculateSentimentScore();
  const riskAnalysis = calculateRiskScore(spyData, vixData);
  
  // Total score
  const totalScore = technicalAnalysis.score + fundamentalAnalysis.score + 
                     sentimentAnalysis.score + riskAnalysis.score;
  
  // Quality gates
  const qualityGates = checkQualityGates(stockData, spyData, technicalAnalysis);
  
  // Verdict
  const verdict = determineVerdict(totalScore, qualityGates, technicalAnalysis.rsData);
  
  // Debug logging
  console.log('=== SCORING ENGINE DEBUG ===');
  console.log('Stock:', stockData.ticker);
  console.log('Technical Score:', technicalAnalysis.score, '/', technicalAnalysis.maxScore);
  console.log('Technical Details:', technicalAnalysis.details);
  console.log('Fundamental Score:', fundamentalAnalysis.score, '/', fundamentalAnalysis.maxScore);
  console.log('Fundamental Details:', fundamentalAnalysis.details);
  console.log('Fundamental Data Source:', fundamentalAnalysis.dataSource);
  console.log('Fundamental Data Quality:', fundamentalAnalysis.dataQuality);
  console.log('Sentiment Score:', sentimentAnalysis.score, '/', sentimentAnalysis.maxScore);
  console.log('Risk Score:', riskAnalysis.score, '/', riskAnalysis.maxScore);
  console.log('Total Score:', totalScore, '/ 75');
  console.log('Quality Gates:', qualityGates);
  console.log('Verdict:', verdict);
  console.log('============================');
  
  return {
    ticker: stockData.ticker,
    name: stockData.name,
    currentPrice: stockData.currentPrice,
    totalScore: totalScore,
    maxScore: 75,
    verdict: verdict,
    qualityGates: qualityGates,
    breakdown: {
      technical: technicalAnalysis,
      fundamental: fundamentalAnalysis,
      sentiment: sentimentAnalysis,
      risk: riskAnalysis
    },
    rsData: technicalAnalysis.rsData,
    indicators: technicalAnalysis.indicators,
    timestamp: new Date().toISOString()
  };
}