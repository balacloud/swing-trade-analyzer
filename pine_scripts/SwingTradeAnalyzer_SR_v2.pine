// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © SwingTradeAnalyzer
// v2.0 - Enhanced with swing trading rules:
//   - Lookback limit (recent levels only, default 18 months)
//   - Multiple rejection requirement (min 2 touches)
//   - Role reversal detection (support↔resistance)
//   - Avoid outlier extremes
//   - Multi-timeframe color coding

//@version=6
indicator("STA S&R v2.0", shorttitle="STA S&R v2", overlay=true, max_lines_count=100, max_labels_count=100)

// ============================================
// INPUTS
// ============================================
grp_lookback = "Lookback Settings"
lookbackBars = input.int(378, "Lookback Bars (378 = 18mo)", minval=50, maxval=1000, group=grp_lookback, tooltip="Only consider pivots within this many bars. 252=1yr, 378=18mo")
minTouches = input.int(2, "Min Touches Required", minval=1, maxval=5, group=grp_lookback, tooltip="Level must have this many rejections to be valid")
touchZonePct = input.float(1.0, "Touch Zone %", minval=0.5, maxval=3.0, step=0.5, group=grp_lookback, tooltip="How close price must come to count as a touch")

grp_pivot = "Pivot Detection"
pivotStrength = input.int(5, "Pivot Strength", minval=2, maxval=20, group=grp_pivot, tooltip="Bars left/right to confirm pivot")
maxLevels = input.int(5, "Max Levels Per Side", minval=1, maxval=10, group=grp_pivot)
avoidExtremes = input.bool(true, "Avoid Extreme Outliers", group=grp_pivot, tooltip="Skip absolute 52w high/low as levels")

grp_display = "Display"
showSupport = input.bool(true, "Show Support", group=grp_display)
showResistance = input.bool(true, "Show Resistance", group=grp_display)
showLabels = input.bool(true, "Show Labels", group=grp_display)
showTouchCount = input.bool(true, "Show Touch Count", group=grp_display)

grp_colors = "Colors (by Strength)"
weakColor = input.color(color.new(color.gray, 50), "Weak (2 touches)", group=grp_colors)
mediumColor = input.color(color.new(color.yellow, 30), "Medium (3-4 touches)", group=grp_colors)
strongColor = input.color(color.new(color.lime, 0), "Strong (5+ touches)", group=grp_colors)
resistanceHue = input.color(color.new(color.red, 30), "Resistance Tint", group=grp_colors)

// ============================================
// HELPER: Count touches at a level
// ============================================
countTouches(float level, int startBar, float zonePct) =>
    touches = 0
    zoneSize = level * zonePct / 100
    upperZone = level + zoneSize
    lowerZone = level - zoneSize

    barsToCheck = math.min(bar_index - startBar, lookbackBars)
    if barsToCheck > 0
        for i = 0 to barsToCheck - 1
            idx = bar_index - i
            if idx >= 0
                h = high[i]
                l = low[i]
                // Check if high or low touched the zone
                if (h >= lowerZone and h <= upperZone) or (l >= lowerZone and l <= upperZone)
                    touches += 1
    touches

// ============================================
// HELPER: Check if level is an extreme outlier
// ============================================
high52w = ta.highest(high, 252)
low52w = ta.lowest(low, 252)

isOutlier(float level) =>
    if not avoidExtremes
        false
    else
        // Skip if within 1% of absolute 52w high or low
        nearHigh = math.abs(level - high52w) / high52w < 0.01
        nearLow = math.abs(level - low52w) / low52w < 0.01
        nearHigh or nearLow

// ============================================
// PIVOT DETECTION (with lookback limit)
// ============================================
pivotHigh = ta.pivothigh(high, pivotStrength, pivotStrength)
pivotLow = ta.pivotlow(low, pivotStrength, pivotStrength)

// Store recent pivots only
var float[] recentPivotHighs = array.new_float(0)
var float[] recentPivotLows = array.new_float(0)
var int[] pivotHighBars = array.new_int(0)
var int[] pivotLowBars = array.new_int(0)

// Track pivot high
if not na(pivotHigh)
    pivotBar = bar_index - pivotStrength
    // Only add if within lookback and not outlier
    if bar_index - pivotBar <= lookbackBars and not isOutlier(pivotHigh)
        // Check if unique (not within 1.5% of existing)
        isUnique = true
        if array.size(recentPivotHighs) > 0
            for i = 0 to array.size(recentPivotHighs) - 1
                if math.abs(pivotHigh - array.get(recentPivotHighs, i)) / pivotHigh < 0.015
                    isUnique := false
                    break
        if isUnique
            array.push(recentPivotHighs, pivotHigh)
            array.push(pivotHighBars, pivotBar)

// Track pivot low
if not na(pivotLow)
    pivotBar = bar_index - pivotStrength
    if bar_index - pivotBar <= lookbackBars and not isOutlier(pivotLow)
        isUnique = true
        if array.size(recentPivotLows) > 0
            for i = 0 to array.size(recentPivotLows) - 1
                if math.abs(pivotLow - array.get(recentPivotLows, i)) / pivotLow < 0.015
                    isUnique := false
                    break
        if isUnique
            array.push(recentPivotLows, pivotLow)
            array.push(pivotLowBars, pivotBar)

// Cleanup old pivots outside lookback
if barstate.islast
    // Remove old pivot highs
    if array.size(recentPivotHighs) > 0
        for i = array.size(recentPivotHighs) - 1 to 0
            if array.size(pivotHighBars) > i
                if bar_index - array.get(pivotHighBars, i) > lookbackBars
                    array.remove(recentPivotHighs, i)
                    array.remove(pivotHighBars, i)

    // Remove old pivot lows
    if array.size(recentPivotLows) > 0
        for i = array.size(recentPivotLows) - 1 to 0
            if array.size(pivotLowBars) > i
                if bar_index - array.get(pivotLowBars, i) > lookbackBars
                    array.remove(recentPivotLows, i)
                    array.remove(pivotLowBars, i)

// ============================================
// GET COLOR BY TOUCH COUNT
// ============================================
getColorByTouches(int touches, bool isResistance) =>
    baseColor = touches >= 5 ? strongColor : touches >= 3 ? mediumColor : weakColor
    // Tint resistance slightly red
    isResistance ? color.new(color.red, color.t(baseColor) + 20) : baseColor

getLineWidth(int touches) =>
    touches >= 5 ? 3 : touches >= 3 ? 2 : 1

// ============================================
// DRAW LEVELS
// ============================================
var line[] drawnLines = array.new_line(0)
var label[] drawnLabels = array.new_label(0)

if barstate.islast
    // Clear old drawings
    if array.size(drawnLines) > 0
        for i = 0 to array.size(drawnLines) - 1
            line.delete(array.get(drawnLines, i))
    if array.size(drawnLabels) > 0
        for i = 0 to array.size(drawnLabels) - 1
            label.delete(array.get(drawnLabels, i))
    array.clear(drawnLines)
    array.clear(drawnLabels)

    currentPrice = close

    // Collect all valid levels with touch counts
    var float[] validLevels = array.new_float(0)
    var int[] levelTouches = array.new_int(0)
    var bool[] levelIsResistance = array.new_bool(0)
    var int[] levelStartBars = array.new_int(0)

    array.clear(validLevels)
    array.clear(levelTouches)
    array.clear(levelIsResistance)
    array.clear(levelStartBars)

    // Process pivot highs (potential resistance)
    if array.size(recentPivotHighs) > 0
        for i = 0 to array.size(recentPivotHighs) - 1
            level = array.get(recentPivotHighs, i)
            startBar = array.get(pivotHighBars, i)
            touches = countTouches(level, startBar, touchZonePct)

            if touches >= minTouches
                array.push(validLevels, level)
                array.push(levelTouches, touches)
                array.push(levelIsResistance, level > currentPrice)
                array.push(levelStartBars, startBar)

    // Process pivot lows (potential support)
    if array.size(recentPivotLows) > 0
        for i = 0 to array.size(recentPivotLows) - 1
            level = array.get(recentPivotLows, i)
            startBar = array.get(pivotLowBars, i)
            touches = countTouches(level, startBar, touchZonePct)

            if touches >= minTouches
                // Check if already added from highs (role reversal!)
                alreadyExists = false
                if array.size(validLevels) > 0
                    for j = 0 to array.size(validLevels) - 1
                        if math.abs(level - array.get(validLevels, j)) / level < 0.015
                            // Boost touch count for role reversal!
                            existingTouches = array.get(levelTouches, j)
                            array.set(levelTouches, j, existingTouches + touches)
                            alreadyExists := true
                            break

                if not alreadyExists
                    array.push(validLevels, level)
                    array.push(levelTouches, touches)
                    array.push(levelIsResistance, level > currentPrice)
                    array.push(levelStartBars, startBar)

    // Draw support levels
    drawnSupport = 0
    if showSupport and array.size(validLevels) > 0
        for i = 0 to array.size(validLevels) - 1
            if drawnSupport >= maxLevels
                break
            level = array.get(validLevels, i)
            isRes = array.get(levelIsResistance, i)

            if not isRes  // Support = below current price
                touches = array.get(levelTouches, i)
                startBar = array.get(levelStartBars, i)

                lineColor = getColorByTouches(touches, false)
                lineWidth = getLineWidth(touches)

                newLine = line.new(startBar, level, bar_index + 20, level,
                     color=lineColor, width=lineWidth, style=line.style_solid,
                     extend=extend.right)
                array.push(drawnLines, newLine)

                if showLabels
                    touchText = showTouchCount ? " [" + str.tostring(touches) + "x]" : ""
                    labelText = "S " + str.tostring(level, "#.##") + touchText
                    newLabel = label.new(bar_index + 5, level, labelText,
                         color=color.new(lineColor, 80), textcolor=lineColor,
                         style=label.style_label_left, size=size.small)
                    array.push(drawnLabels, newLabel)

                drawnSupport += 1

    // Draw resistance levels
    drawnResistance = 0
    if showResistance and array.size(validLevels) > 0
        for i = 0 to array.size(validLevels) - 1
            if drawnResistance >= maxLevels
                break
            level = array.get(validLevels, i)
            isRes = array.get(levelIsResistance, i)

            if isRes  // Resistance = above current price
                touches = array.get(levelTouches, i)
                startBar = array.get(levelStartBars, i)

                lineColor = getColorByTouches(touches, true)
                lineWidth = getLineWidth(touches)

                newLine = line.new(startBar, level, bar_index + 20, level,
                     color=lineColor, width=lineWidth, style=line.style_solid,
                     extend=extend.right)
                array.push(drawnLines, newLine)

                if showLabels
                    touchText = showTouchCount ? " [" + str.tostring(touches) + "x]" : ""
                    labelText = "R " + str.tostring(level, "#.##") + touchText
                    newLabel = label.new(bar_index + 5, level, labelText,
                         color=color.new(lineColor, 80), textcolor=lineColor,
                         style=label.style_label_left, size=size.small)
                    array.push(drawnLabels, newLabel)

                drawnResistance += 1

// ============================================
// INFO TABLE
// ============================================
var table infoTable = table.new(position.top_right, 2, 5, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast
    // Count levels by strength
    strongCount = 0
    mediumCount = 0
    weakCount = 0

    if array.size(validLevels) > 0
        for i = 0 to array.size(levelTouches) - 1
            t = array.get(levelTouches, i)
            if t >= 5
                strongCount += 1
            else if t >= 3
                mediumCount += 1
            else
                weakCount += 1

    table.cell(infoTable, 0, 0, "STA S&R", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 0, "v2.0", text_color=color.gray, text_size=size.small)

    table.cell(infoTable, 0, 1, "Strong (5+)", text_color=strongColor, text_size=size.tiny)
    table.cell(infoTable, 1, 1, str.tostring(strongCount), text_color=color.white, text_size=size.tiny)

    table.cell(infoTable, 0, 2, "Medium (3-4)", text_color=mediumColor, text_size=size.tiny)
    table.cell(infoTable, 1, 2, str.tostring(mediumCount), text_color=color.white, text_size=size.tiny)

    table.cell(infoTable, 0, 3, "Weak (2)", text_color=weakColor, text_size=size.tiny)
    table.cell(infoTable, 1, 3, str.tostring(weakCount), text_color=color.white, text_size=size.tiny)

    table.cell(infoTable, 0, 4, "Lookback", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTable, 1, 4, str.tostring(lookbackBars) + " bars", text_color=color.gray, text_size=size.tiny)
